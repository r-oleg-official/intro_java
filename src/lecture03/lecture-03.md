## Lecture #3. Коллекции Java. Введение.
### План
1. Тип, который может быть чем угодно
2. Обобщения
3. Массивы и их проблемы
4. Самая "простая" коллекция
5. Функционал
6. Куда двигаться дальше

Коллекций в Java много и для каждой задачи надо исп. свою. Есть набор конкретных коллекций, которые часто используются, 
но в общем случае, их сильно, сильно больше. 

### Object.
Тип данных `Object` - "всему голова". 
1. В Java есть тип `Object`. Когда рассматриваются строго типизированные ЯП, то в большинстве случаев есть что-то, что
лежит в основе этого языка. 

Примерно, как в математике. В основе всего лежат числа, дальше переходим к буквенным выражениям. После этого думаем: 
каким образом прим. эту математику в решении задач. Дальше переходим к уравнениям. Дальше думаем как использовать 
систему уравнения. И далее более серьезные математические объекты. 

Примерно тож самое и в программировании. Есть какой-то базис, основа основ и на неё накладывается всё остальное. Так 
вот этой основой в Java, но на самом деле Сергей делает отсылку к C#, является тип данных `Object`. Получается любое 
значение любого типа может быть положено в тип `Object` и процесс этот наз. "запаковкой". В некоторой лит-ре могут 
наз. "упаковкой", но суть от этого не меняется.

После того, как какоее-то значение было положено в `Object`, в момент когда надо будет извлекать значение - таким же 
образом из `Object`'а можно положить в конкретный тип. 

Пример, если взяли число `5` и положили его в `Object`, число будет там храниться. Как хранятся данные в памяти будет 
позже рассмотрено. Далее поработали с этим `Object` и внезапно понадобилось извлечь данные именно в контексте того 
типа, который был изначально задан. Т.е. надо взять `Object` и "скастовать" его в `Integer` чтобы, напр., произвести 
какие-то ариф.-е действия. Соответственно, процесс обратный "упаковки" наз. "распаковкой".

Теперь можно рассматривать иерархию типов.

##### **Иерархия типов** - любой тип "ниже" `Object`'а.
Для того, чтобы было более понятно, можно взять классический пример из биологии.

Животные -> Млекопитающие -> приматы -> Человек разумный.

Рассмотрим царство "Животных", где-то там есть "Млекопитающие", далее, спускаясь, получаем "Приматов", дальше получаем 
"Человека разумного". 

0:05:02 - Сергей разделяет млекопитающих и кошек. Кошки - семейство кошачьих класса "млекопитающих". Соответственно, 
если начинаем разобщать эту теорию, получается так, что если возьмем млекопитающее и какое-нибудь семейство котиковых, 
да кошачьи, то мы точно можем сказать, что любой котик является животным. Также, с точки зрения биологии, и человек 
тоже животное.

Т.е. мы берем какую-то основу и на неё можем накладывать какие-то конкретные иерархии. После того как мы поняли, что
любой тип может быть положен в `Object` - наша задача попробовать это на практике.


    public class Ex01_object {
        public static void main(String[] args) {
            Object o = 1; GetType(o);   // java.lang.Integer
            o = 1.2; GetType(o);        // java.lang.Double
            }
            
            static void GetType(Object obj) {
                System.out.println(obj.getClass().getName());
            }
    }

В `Object` сначала положена переменная типа `Integer`, передавая в метод GetType() переменную типа `Object`, 
соответственно внутри данного метода выводится информация о том типе переменной, которую передали. Второй раз передается
переменная типа `Double`.

> Внимание! Если бы писали классическое определение данного метода - нам бы пришлось писать отдельно `GetType()` для 
> типа `Integer`. Дальше пришлось бы писать отдельно для типа `Double`, дальше бы отдельно писали для типа `String`. 

И на самом деле в ЯП Java есть сотни и тысячи типов. Если бы мне захотелось описать метод, который получал информацию 
о типе для каждого этого самого типа (тавтология), то мне пришлось бы описывать 10 тысяч методов. Но благодаря такой 
иерархии, можно сказать: нужный тип, конкретный тип запаковываю в `Object`, передаю в метод. В методе происходит 
"внутрення кухня", которая позволяет распаковать этот тип и посмотреть что в нем храниться, получив информацию о типе и
соответственно чем этот тип наполнен. Для `Integer` можем сказать "вот так работать", для `Double` будет по другому.
Для `String` будет по-третьему и так далее.

#### Пример, для сложения двух чисел `Integer`.
По-хорошему, в Java надо писать метод для каждого типа. В Java есть ещё: `Double`, `short`, `sbyte` и др. Также в 
Java есть `"классы-обертки"`. Нам пришлось бы описывать много однотипных, в смысле логики методов для отдельного 
сложения `Integer`, `Double` и т.д.


    class Ex02_object {
        public static void main(String[] args) {
            System.out.println(Sum(1, 2));      // 1.
            System.out.println(Sum(1.0, 2));    // 2.
            System.out.println(Sum(1, 2.0));    // 3.
            System.out.println(Sum(1.2, 2.2));  // 4.
        }
    }

Во-втором случае, создается перегрузка методов, передавая `1.0` в `Sum()`. Таким образом получается 1-е число - 
вещественное, а второе целочисленное. 3-й случай - как 2-й случай, только наоборот. В 4-м случае оба числа - 
вещественные.

Можно и комплексные числа передавать. Что в этом случае делать?

Технически, не зная о процессах упаковки, распаковки и иерархии типов пришлось бы делать отдельные методы, в которые 
принимаются `Integer` и `Integer`, `Double` и `Integer`, и т.д. 

    static int Sum(int a, int b){return a + b;}
    static double Sum(double a, double b){return a + b;}

А что, если с точностью до нашей иерархии, а учитывая что можно делать `конкатенацию строк` - как описывать сумму двух 
строк? Абсолютно, аналогичным образом: 

    static String Sum(String a, String b){return a + b;}

Возвращаясь к вопросу: зачем нужен `Object`? Здесь достаточно просто, можно взять один отдельный метод, в котором 
указать в качестве аргументов `Object`'ы и дальше абсолютно спокойно проверить: `a instnaceof Double` (если `а` 
является `Double`, переменная `а` типа `Double`, или `а` принадлежит к типу `Double`) и `b` принадлежит к тому же 
типу - то берем переменную `a`, привести явно к типу `Double` - `(Double)`, сделать то же самое для переменной `b`. 
Затем получившееся преобразования сложить и результат обратно запаковать в тип `Object`.

    static Object Sum(Object a, Object b) {
        if (a instanceof Double && b instanceof Double) {
            return (Object) ((Double) a + (Double) b);
        } else if (a instanceof Integer && b instanceof  Integer) {
            return (Object) ((Integer) a + (Integer) b);
        } else return 0;
    }
0:9:21
Технически можно сделать так, что при возвращении типа `Object` у метода возвращаем `1,2` - это можно сделать. Но с 
точки зрения более правильного, грамотного описания: какие типы мы возвращаем; поэтому здесь в методе превращаем в тип
`Object`. Но в данном случае, это делать необязательно. 

> Сергей сказал, что сложить `String` можно методом `.concat()`.

Получается так, что метод один, но какое большое кол-во проверок. И если `if` будет состоять из 100-а веток, получается,
передавая 2 непонятных аргумента мы должны пробежать по всему этому каскаду `if`'ов и делать дополнительную проверку.
В связи с этим получается очень долгое выполнение этого самого метода, а как следствие это сказывается на 
производительности, а как следствие - это плохо.

Если код написан для одного человека - нормально, но если код написан для сервиса, которым пользуются тысячи, сотни 
тысяч человек. То в этом случае, потеря производительности будет очень-очень большой. Сейчас, когда мы начинаем 
проектировать должны думать о том, каким образом это должно работать. 

>Чем меньше преобразований из `Object` в `Object` - тем быстрее будет работать.

Даже если мы опишем каскад для всех типов, как нам кажется будут использованы - `Object` может принимать в себя всё 
что угодно и обязательно найдется пользователь который 100% укажет переменные типа, которые у нас не обрабатываются. 
И условная `Sum("маша", "каша") = 0`. 

>Используя тип `Object` нужно быть очень аккуратным. Т.е. прибегать к этому механизму упаковки-распаковки нужно 
> прибегать в крайнем-крайнем случае.

### Массивы.
Какие есть проблемы при использовании массивов?

Классический пример. Есть массив, состоящий из 2-х элементов. Что делать, если потребуется 3 эл-та, 4 эл-та, 5 эл-тов?
Если в `Python` есть список, то он "сам это сделает". И вот это "сам все сделает" - сильно сказывается на 
производительности.

Если задумаем написать такой функционал, то:
1. возьмем 1 массив;
2. дальше возьмем 2-й массив, увеличив его размер;
3. все элементы 1-го массива скопировать во 2-й;
4. и дальше работать со вторым массивом.

Пример. Есть массив из 2-х элементов. Потребовалось добавить 3-й элемент. 

    class Ex03_object {
        public static void main(String[] args) {
            int[] a = new int[] {1, 9};
            int[] b = new int[3];
            System.arraycopy(a, 0, b, 0, a.length);
        
            for (int i : a) { System.out.printf("%d ", i); }    // 1 9
        
            for (int j: b) { System.out.printf("%d ", j); }
            // 0 9 0 0 0 0 0 0 0 0
        } }

1. создан массив `a` с двумя элементами;
2. создан пустой массив `b` для 3-х элементов {1, 9};
3. далее методом `.arraycopy()` указываем, что надо из массива `a` в `b` скопировать данные, начиная с `0`-го элемента
и всю длину массива (кол-во) `a.length` элементов массива `a`.  

Можно создать метод для добавления эл-та в массив.


    class Ex04_object {
        static int[] AddItem(int[] array, int item) {
            int length = array.length;
            int[] temp = new int[length + 1];
            System.arraycopy(array, 0, temp, 0, length);
            temp[length] = item;
            return temp;
        }
        public static void main(String[] args) {
            int[] a = new int[] {0, 9};
            for (int i : a) { System.out.printf("%d ", i); }    // 0 9
            a = AddItem(a, 2);
            a = AddItem(a, 3);
            for (int j : a) { System.out.printf("%d ", j); }    // 0 9 2 3
        } }

В метод `AddItem()` передается массив и эл-т который надо добавить. Здесь нужно обратиться к архитектуре компа. 
Что происходит в памяти компьютера? 
> Знать это наизусть необязательно. Но это могут спросить на собеседовании, напр., вытащить джуна, интерна и 
> задать ему совсем тривиальные вопросы. Им нужно понять: насколько джун понимает плохо это, или хорошо исп. данный 
> метод. 

См. презентацию. Есть опер.-я память. Память делится на 2 больших участка. 
1. `STACK`, стек;
2. `HEAP` - управляемая куча. 

В стеке определяются те типы, с которыми, как правило, известно как работать. Допустим определили перем-ю `Integer`. 
Очевидно перем-я такого типа занимает 4 байта и ни при каких условиях она не может стать 5-ю, 10-ю байтами. 
Соответственно, для `Integer` в стеке определяется 4 байта.

Напр., на след.-м этапе надо определить перем-ю типа `String`, то сколько памяти выделять? Непонятно, потому-что в 
строку можно положить слово `маша`, тогда 1 символ занимает 2 байта, значит слово `маша` занимает 8 байт. А если в эту 
переменную решили положить том "Война и мир" тогда размер в памяти будет сильно больше. То же самое и с массивами когда 
определяете перем-ю типа `array` не знаете: сколько эл-тов будет в ней? Это тот самый момент, когда в коде указано 
`new int...` - в этот момент происходит выделение памяти в кучу. Причем саму переменную тоже надо где-то хранить. 
И вот эта ссылка, которая представляется идентификатором массива она будет сохраняться в стеке, а всё что присвоить 
`new ...` - это будет сохраняться в куче, или `управляемой куче`.  

    int[] a = new int[];

Допустим надо объявить массив с назв. `a`. В `STACK` появится `a`. После этого когда указываем присвоить `=`
`new что-то там...`, то где-то в "куче" выделяется память чтобы эти самые данные хранить. Если в массиве будет 10 
эл-тов, то выделится 40 байт, (?? 0:16:31) если речь про `Integer`, если 20 эл-тов то 80 байт памяти, соответственно и 
т.д. 

Далее, когда захотели создать, или увеличить кол-во элементов в этом массиве через этот вспомогательный функционал 
`System.arraycopy()`, или отдельный метод, то в любом случае будет происходить примерно след.-е:

Пример, когда просто скопировать, 1-й. В этом случае где-то в стеке будет размещен этот массив `temp`, в контексте 
предыдущего примера увеличения массива это был массив `b`. Когда указываем `= new int[length = 1]` в новом участке 
памяти "кучи" будет определен новый кусочек `nd` где будем хранить новые эл-ты. Далее происходит перегон эл-тов из 
участка памяти `d` где хранились эл-ты `a` в тот участок памяти `HEAP` где хранятся эл-ты `b` - `nd`. После того как 
скопировали, происходит подмена ссылки `a -> d` на `a -> nd` , т.е. в этом случае, `a` будет ссылаться на новое место 
в "куче" `nd`. Потом сначала сотрется ссылка `a -> d`. Ссылку можно называть "адрес памяти". Далее сотрется ссылка 
`temp -> nd`. И останется ссылка `a -> nd`.

> Итог. взяли данные и переместили в другой участок памяти.

Как понимаете, если это делать много раз и ещё для миллиона пользователей то это сильно сказывается на 
производительности. Поэтому к таким операциям нужно быть очень-очень быть аккуратным. 

> На будущее. Если потребуется массив на 10, или 100 эл-тов, то лучше задать размер с запасом чуть-чуть побольше и 
> пусть оно там хранится. 

Если нужно будет уменьшать массив, то это будет происходить аналогичным способом. 

Пример копирования с методом `AddItem()`. В этом случае механизм будет чуть другим.
Есть массив `a` в стеке с данными `d` в "куче". `a -> d`. Будет определена перем-я `array`, она будет хранить ссылку 
на тот же участок памяти `array -> d`. В методе `AddItem()` выделим новый участок памяти в "куче" `temp -> nd`. 

Далее после `arraycopy()` добавятся ссылки `a -> nd` и `'array -> nd`, а ссылки `a -> d` и `array -> d` удалятся. 
Потом удалится ссылка `temp -> nd`, после выполнения метода останется ссылка `a -> nd`. Теперь данные будут 
содержаться в исходном массиве `a`, или ссылка на эти данные будет содержаться в `a`. 
0:19:45

> Мораль. Добавлять/удалять по одному эл-ту массива - невыгодно. Или брать сразу с запасом, или схитрить, как и сделали 
> разработчики Java. Их идея заключалась в том, что если у нас в рамках задачи потребуется 10 эл-тов, то выделим эти 
> 10 эл-тов. Если вдруг понадобиться добавить 11-й, то скорее всего потребуется и 12-й. Поэтому размер массива 
> увеличивается в 2 раза. Если указали 20 эл-тов, после этого решили добавить 21-й эл-т, то в этом случае кол-во эл-тов 
> будет не 21, а 40. Когда потребуется 41-й - будет 80 и т.д. Возможно это неверные числа, в док-ции есть ответ.

### Коллекции. 
Для того чтобы не используя массивы, не делая эту обвязку добавления/удаления эл-тов массива - есть коллекции. 

##### Иерархия коллекций.
**<<interface\>>** Collection:
1. **<<interface\>>** List:
* ArrayList
* Vector
2. **<<interface\>>** Set:
* HashSet
  - LinkedHashSet
* **<<interface\>>** SortedSet
  - **<<interface\>>** NavigabledSet
    + TreeSet
3. **<<interface\>>** Queue:
* LinkedList
* PriorityQueue

> **Collections** - это не есть **Collection**. Когда гуглишь, выдает про **Collections**, надо иметь в виду.   

В основе иерархии коллекций находится интерфейс **Collection**. От которого наследуются, или наследуются `List`, 
`Set`, `Queue`.

Множество коллекции `MAP` таким же образом является коллекцией, но в то же время в такой иерархии они идут особняком.

В данной иерархии есть коллекции рекомендуемые к использованию, а есть устаревшие и их как бы не рекомендуется 
использовать в новых проектах. Но так, или иначе с некоторыми из них будем знакомиться.

> В Java сделана поддержка "обратной совместимости", т.е. то что было сделано 10 лет назад на старых версиях языка Java 
> должно работать на новых версиях языка. Т.е., те проекты, написанные давно может функционировать до сих пор.

С одной стороны можно взять старые проекты, переписать и поставить на новые рельсы, но в большом продакшене все 
переписать - это задача не из легких. Поэтому отсюда правило:

> Вот оно работает - не лезь!

Если пишется какой-то новый сервис, в нем используется новый функционал. Тем более, если идешь в тестировку, то 
вероятность знания старых фичей так, или иначе будет нужно.  

Для начала возьмем самый простой пример коллекций - `ArrayList`. 

#### ArrayList. 0:23:10
##### "Удобный массив". Но это является коллекций.

    ArrayList list = new ArrayList();

С точки зрения памяти, всё аналогично как с массивами. В `STACK`е выделяется для `list` (ссылка) где-то 4 байта. Далее 
используя конструктор `new` выделяется какое-то кол-во памяти в куче `HEAP` (data). А дальше механизмы могут быть 
разные. В одних коллекциях могут быть массивы, в других могут лежать списки.

#### List. Список. 0:24:07
Рассмотрим самый простой пример коллекции - `List`.

Учитывая иерархию типов, иерархию коллекций, то в основе лежит `List`. То когда речь будет о конкретной коллекции, 
которая реализует этот самый `List`, то на самом деле можем говорить о `List`'ах.

В данном случае к `List` относятся: `ArrayList`, `LinkedList` (`Vector`, `Stack` - устаревшие). 

Основная идея заключается в том, что если есть функционал для одной коллекции, он есть и для другой. Да, у них может 
быть разное поведение, но если есть условный метод `.add()`, который добавляет элемент, то он будет справедлив как для 
`ArrayList`, так и для `LinkedList` и т.д. Каким образом данные будут храниться внутри сейчас не знаете. Но то что 
справедливо для общего, т.е. для `List`, то справедливо и для конкретного представителя.

> `List` - пронумерованный набор элементов.

Пользователь этого интерфейса имеет точный контроль над тем, где в списке вставляется каждый элемент.

Пользователь может обращаться к элементам по их целочисленному индексу (позиции в списке) и искать элементы в списке.

Конкретная коллекция `ArrayList` может быть в общем `List`'е: 

    List list = new ArrayList();

Но, если `List` смущает, то можно написать с обеих сторон `ArrayList`:

    ArrayList list = new ArrayList();

Пример:

    class  Ex05_ArrayList {
      public static void main(String[] args) {
          List list = new ArrayList(); // через Object
          // or
          // ArrayList list = new ArrayList();
          list.add(2809);
        
          for (Object o: list) {
              System.out.println(o);
            }
      } }

Дело в том, что в контексте Java есть такое понятие как `сырые типы` и вот в данном примере когда описали `ArrayList` в 
таком контексте, мы делаем неявное преобразование к `Object`. Т.е. когда мы определили `ArrayList`, явно не указав, не 
обозначив тип данных с которыми будет работать `ArrayList` - мы используем тот самый `Object`. Т.е. забрасываем данные 
методом `.add()`, мы преобразуем `Integer` в `Object`. На это тратиться определенное время. Дальше когда будут 
извлекаться данные, точно таким же образом нужно будет делать проверку на `instanceof`, т.е. чем именно, каким типом 
являются те данные, которые мы извлекаем из нашей коллекции.

Для того чтобы этого избежать, надо явно указать с каким типом мы работаем. Делается след.-м образом:

    ArrayList<Integer> list = new ArrayList<Integer>();

В угловых скобках `< >`, наз. "Обобщение" нужно указать тип данных списка слева от `=`, технически и справа. 

Если не указать тип в `<Integer>`, то можно в один список добавлять эл-ты разных типов как в след примере:

    ArrayList list = new ArrayList();
    list.add(2809);
    list.add("1234");

А в след примере получим ошибку, т.к. пытаемся в целочисленный список добавить строковый эл-т: 

    ArrayList<Integer> list = new ArrayList<Integer>();
    list.add(2809);
    list.add("1234");

> Указывая тип списка избавляешь от потенциально возможно большого приведения типов.

Примеры объявления списков:

    ArrayList<Integer> list1 = new ArrayList<Integer>();
    ArrayList<Integer> list2 = new ArrayList<>();
    ArrayList<Integer> list3 = new ArrayList<>(10);     // изначально будет 10 эл-тов, можно потом добавлять
    ArrayList<Integer> list4 = new ArrayList<>(list3);  // создать новую коллекцию, копируя другую

##### Коллекции. Row Type (сырой тип)

    import java.util.ArrayList;
    import java.util.List;
    class  Ex05_ArrayList {
      public static void main(String[] args) {
        List list = new ArrayList();
        list.add(2809);
        list.add("string line");

        for (Object o: list) { System.out.println(o); }
      } }
    // row type java

##### Коллекции. Save Type

    import java.util.ArrayList;
    import java.util.List;
    class  Ex05_ArrayList {
      public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(123);
        // list.add("string line");
        
        for (Object o: list) { 
          System.out.println(o); 
          // Проблема извлечения данных
          }
      } }

На этапе компиляции будет обнаружена ошибка добавления строковых данных и это избавит от кучи ошибок в дальнейшем.

Преимущества использования обобщения:
1. избавление себя от ошибок;
2. код можно много раз переиспользовать. Соответственно, если опишешь один раз общую механику того как добавляются 
эл-ты, напр., для `Integer` то таки образом можно делать и для: строк, вещественных чисел, символов, логических 
значений, или для тех типов, которые будете создавать самостоятельно.  

##### Коллекции. Функционал.
* **add(args)** - добавляет эл-т в список (в т.ч. на нужную позицию)
* **get(pos)** - возвращает эл-т из списка по указанной позиции
* **indexOf(item)** - первое вхождение, или -1
* **lastIndexOf(item)** - последнее вхождение, или -1
* **remove(pos)** - удаление эл-та на указанной позиции и его возвращение
* **set(int pos, T item)** - помещает значение item эл-ту, который находится на позиции pos
* **void sort(Comparator)** - сортирует набор данных по правилу
* **subList(int start, int end)** - получение набора данных от позиции start до end

В частности может получиться так, что наполняем свою коллекцию "специфичными типами" (ссылочными). Что может пойти не 
так? 

    import java.util.Arrays;
    import java.util.List;
    
    class  Ex06_Method {
      public static void main(String[] args) {
        int day = 29;
        int month = 9;
        int year = 1990;
        Integer[] date = {day, month, year};
        List<Integer> d = Arrays.asList(date);
        System.out.println(d);  // [29, 9, 1990]
      } }

Допустим есть некоторые числа. Далее числа положить в массив `date`. Далее на основе этого массива можно спокойно 
сформировать коллекцию. Все работает.

Но, в один прекрасный момент может получиться так что вместо этих примитивных типов, пусть даже через классы-обертки 
начали использовать более сложные типы. Можно посмотреть на предыдущий пример, но используя `StringBuilder` и наполняя 
его какими-то строковыми значениями.

    import java.util.Arrays;
    import java.util.List;
    import static java.util.Arrays.*;
    
    class  Ex07_ArraysMethod {
      public static void main(String[] args) {
        StringBuilder day = new StringBuilder("29");
        StringBuilder month = new StringBuilder("9");
        StringBuilder year = new StringBuilder("1990");
        StringBuilder[] date = new StringBuilder[]{day, month, year};
        List<StringBuilder> d = Arrays.asList(date);
        System.out.println(d);  // [29, 9, 1990]
        date[1] = new StringBuilder("09");
        System.out.println(d);  // [29, 09, 1990]
      } }

>При первом выводе коллекции `d` результат очевиден. Далее заменяем значение 2-го эл-та массива `date` и видно, что при 
>замене также поменялось и значение 2-го эл-та коллекции `d`. 

Сергей предлагает взять листок и ручку и попытаться разобраться каким образом происходит и почему происходит такая 
замена в памяти? 
0:32:55

Здесь `StringBuilder` является ссылочным типом. `day`, `month`, `year` будут определяться в `STACK`, а значения 
определяются в куче `HEAP`. Аналогичным образом это работает для массива `StringBuilder`'ов и абсолютно точно таким же 
образом работает для коллекций `StringBuilder`'ов.

Можно порисовать стрелочки чтобы было понимание, почему изменение значения в массиве приводит к изменению в коллекции?

##### Коллекции. String. StringBuilder. Функционал.
* **clear()** - очистка списка 
* **toString()** - "конвертация" списка в строку
* **Arrays.asList()** - преобразует массив в список
* **containsAll(col)** - проверяет включение всех элементов из `col`
* **removeAll(col)** - удаляет элементы, имеющиеся в `col`
* **retainAll(col)** - оставляет элементы, имеющиеся в `col`
* **toArray()** - конвертация списка в массив `Object`'ов
* **toArray(type array)** - конвертация списка в массив `type`
* **List.copyOf(col)** - возвращает копию списка на основе имеющегося
* **List.of(item1, item2,...)** - возвращает неизменяемый список.

Пример создания списка символов на основе `List.of()`:

    class  Ex08_ListOf {
      public static void main(String[] args) {
        Character value = null;
        List<Character> list1 = List.of('S', 'e', 'r', 'g', 'e', 'y');
        System.out.println(list1);
        // list1.remove(1);
        List<Character> list2 = List.copyOf(list1); // java.lang.UnsupportedOperationException
        System.out.println(list2);
      } }

Известно, что в коллекциях есть функционал для удаления эл-тов этой коллекции. То в данном случае в попытке удалить 
символ из коллекции `list1.remove(1)` ожидает ошибка при компиляции `java.lang.UnsupportedOperationException`. Это 
связано с тем что в коллекциях которые создаются при помощи `List.of()` - так просто удалять эл-ты не получится.

    class  Ex09_ListOf {
      public static void main(String[] args) {
        Character value = null;
        List<Character> list1 = new ArrayList<Character>();
        list1.add('S');
        list1.add('e');
        list1.add('r');
        System.out.println(list1);   // [S, e, r]
        list1.remove(1);
        List<Character> list2 = List.copyOf(list1);
        System.out.println(list2);  // [S, r]
      } }

А если сделать по классике `new ArrayList<>()` и добавить `.add()`, тогда при удалении `.remove()` ошибки не произойдет.

#### Итератор.
Что такое `итератор` и `итерируемые объкекты`? 

Напр., при работе с объектом с помощью `foreach` нужно быть уверенным, что объект итерируемый. В контексте ООП будет 
рассказано как создаются итераторы, а пока будет использоваться уже готовый. 

Для того чтобы сделать из коллекции некий итерируемый объект можно взглянуть на код.


    class  Ex10_Iterator {
      public static void main(String[] args) {
        List<Integer> list = List.of(1, 12, 123, 1234, 12345);
  
        for (int item: list) {
          System.out.println(item);
        }
  
        Iterator<Integer> col = list.iterator();
        System.out.println();

        while (col.hasNext()) {
            System.out.println(col.next());
            //col.next();   // java.util.NoSuchElementException
            //col.remove();   // java.lang.UnsupportedOperationException
        }
      } }

Ест обычная коллекция, сформированная с помощью `List.of()`. Далее цикл `foreach`. 

> В цикле `foreach` изменять эл-ты нельзя.

Далее на основе коллекции `list` можно получить итератор `col` в типе `Iterator< >` путем вызова метода `.iterator()`.

Далее в цикл `while`, `col.hasNext()` - пока есть след.-й эл-т в `col` вывести в консоль этот след.-й элемент.

> При чем изменять эту коллекцию `col` не нужно. Т.е., если получаем значение эл-та, не нужно пытаться его удалять 
> `col.remove()`, или дважды его получать `col.next()`. В этом случае ожидать ошибки.

Когда дело касается итераторов. В данном случае есть не что иное, как отсылка к Паттерну каталога `Gof`, который так и 
наз.-ся "итератор". В контексте которого описываете логику того каким образом будем перебирать составные части большой 
какой-то структуры. В нашем примере - это коллекции. В общем случае, можно описать все что угодно.

0:39:17. 
Простой пример. Если у нас есть какая-то большая сущность - "котик", то котик может состоять из шерсти. У котика могут 
быть лапки, хвост и т.д. Соответственно, используя этот итератор, можем поэлементно котика разобрать и дальше с ним 
что-то делать, производить какие-то операции.

Для чего вам может потребоваться разбирать котика? С одной стороны для более гибкой работы с данными, с другой стороны 
мало ли какие хотелки могут возникнуть.  

Дальше желательно поиграть с итераторами. Если речь идет о классическом итераторе `Iterator<E>`, есть функционал: 
`hasNext()`, `next()`, `remove()`.

Интерфейс `Iterator<E>`. Итератор коллекций. Итератор занимает место Enumeration в Java Collections FrameWork. 
Итераторы отличаются от перечислений двумя способами:
1. итераторы позволяют вызывающей стороне удалять элементы из базовой коллекции во время итерации с четко определенной 
семантикой. 

Когда речь идет о более общем функционале, то есть `ListIterator<E>`. Используя `ListIterator<E>` можем гонять данные 
как сначала в конец, так и с конца в начало, причем необязательно по порядку. Можно пройти: 2-й, 4-й эл-т; потом 
вернуться к 3-му эл-ту и т.д.

Функционал `ListIterator<E>`: `hasPrevious()`, `E previous()`, `nextIndex()`, `previousIndex()`, `set(E e)`, `add(E e)`. 

#### Итог.
Отрицание, гнев, торг...

Как можно заметить: знать нужно достаточно много, но в большинстве случаев они такие что один раз попробовал и после 
этого +- понятно как работает. Если что-то непонятно, то можно погуглить.
