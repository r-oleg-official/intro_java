## Lecture #3. Коллекции Java. Введение.
### План
1. Тип, который может быть чем угодно
2. Обобщения
3. Массивы и их проблемы
4. Самая "простая" коллекция
5. Функционал
6. Куда двигаться дальше

Коллекций в Java много и для каждой задачи надо исп. свою. Есть набор конкретных коллекций, которые часто используются, 
но в общем случае, их сильно, сильно больше. 

### Object.
Тип данных `Object` - "всему голова". 
1. В Java есть тип `Object`. Когда рассматриваются строго типизированные ЯП, то в большинстве случаев есть что-то, что
лежит в основе этого языка. 

Примерно, как в математике. В основе всего лежат числа, дальше переходим к буквенным выражениям. После этого думаем: 
каким образом прим. эту математику в решении задач. Дальше переходим к уравнениям. Дальше думаем как использовать 
систему уравнения. И далее более серьезные математические объекты. 

Примерно тож самое и в программировании. Есть какой-то базис, основа основ и на неё накладывается всё остальное. Так 
вот этой основой в Java, но на самом деле Сергей делает отсылку к C#, является тип данных `Object`. Получается любое 
значение любого типа может быть положено в тип `Object` и процесс этот наз. "запаковкой". В некоторой лит-ре могут 
наз. "упаковкой", но суть от этого не меняется.

После того, как какоее-то значение было положено в `Object`, в момент когда надо будет извлекать значение - таким же 
образом из `Object`'а можно положить в конкретный тип. 

Пример, если взяли число `5` и положили его в `Object`, число будет там храниться. Как хранятся данные в памяти будет 
позже рассмотрено. Далее поработали с этим `Object` и внезапно понадобилось извлечь данные именно в контексте того 
типа, который был изначально задан. Т.е. надо взять `Object` и "скастовать" его в `Integer` чтобы, напр., произвести 
какие-то ариф.-е действия. Соответственно, процесс обратный "упаковки" наз. "распаковкой".

Теперь можно рассматривать иерархию типов.

##### **Иерархия типов** - любой тип "ниже" `Object`'а.
Для того, чтобы было более понятно, можно взять классический пример из биологии.

Животные -> Млекопитающие -> приматы -> Человек разумный.

Рассмотрим царство "Животных", где-то там есть "Млекопитающие", далее, спускаясь, получаем "Приматов", дальше получаем 
"Человека разумного". 

0:05:02 - Сергей разделяет млекопитающих и кошек. Кошки - семейство кошачьих класса "млекопитающих". Соответственно, 
если начинаем разобщать эту теорию, получается так, что если возьмем млекопитающее и какое-нибудь семейство котиковых, 
да кошачьи, то мы точно можем сказать, что любой котик является животным. Также, с точки зрения биологии, и человек 
тоже животное.

Т.е. мы берем какую-то основу и на неё можем накладывать какие-то конкретные иерархии. После того как мы поняли, что
любой тип может быть положен в `Object` - наша задача попробовать это на практике.


    public class Ex01_object {
        public static void main(String[] args) {
            Object o = 1; GetType(o);   // java.lang.Integer
            o = 1.2; GetType(o);        // java.lang.Double
            }
            
            static void GetType(Object obj) {
                System.out.println(obj.getClass().getName());
            }
    }

В `Object` сначала положена переменная типа `Integer`, передавая в метод GetType() переменную типа `Object`, 
соответственно внутри данного метода выводится информация о том типе переменной, которую передали. Второй раз передается
переменная типа `Double`.

> Внимание! Если бы писали классическое определение данного метода - нам бы пришлось писать отдельно `GetType()` для 
> типа `Integer`. Дальше пришлось бы писать отдельно для типа `Double`, дальше бы отдельно писали для типа `String`. 

И на самом деле в ЯП Java есть сотни и тысячи типов. Если бы мне захотелось описать метод, который получал информацию 
о типе для каждого этого самого типа (тавтология), то мне пришлось бы описывать 10 тысяч методов. Но благодаря такой 
иерархии, можно сказать: нужный тип, конкретный тип запаковываю в `Object`, передаю в метод. В методе происходит 
"внутрення кухня", которая позволяет распаковать этот тип и посмотреть что в нем храниться, получив информацию о типе и
соответственно чем этот тип наполнен. Для `Integer` можем сказать "вот так работать", для `Double` будет по другому.
Для `String` будет по-третьему и так далее.

#### Пример, для сложения двух чисел `Integer`.
По-хорошему, в Java надо писать метод для каждого типа. В Java есть ещё: `Double`, `short`, `sbyte` и др. Также в 
Java есть `"классы-обертки"`. Нам пришлось бы описывать много однотипных, в смысле логики методов для отдельного 
сложения `Integer`, `Double` и т.д.


    class Ex02_object {
        public static void main(String[] args) {
            System.out.println(Sum(1, 2));      // 1.
            System.out.println(Sum(1.0, 2));    // 2.
            System.out.println(Sum(1, 2.0));    // 3.
            System.out.println(Sum(1.2, 2.2));  // 4.
        }
    }

Во-втором случае, создается перегрузка методов, передавая `1.0` в `Sum()`. Таким образом получается 1-е число - 
вещественное, а второе целочисленное. 3-й случай - как 2-й случай, только наоборот. В 4-м случае оба числа - 
вещественные.

Можно и комплексные числа передавать. Что в этом случае делать?

Технически, не зная о процессах упаковки, распаковки и иерархии типов пришлось бы делать отдельные методы, в которые 
принимаются `Integer` и `Integer`, `Double` и `Integer`, и т.д. 

    static int Sum(int a, int b){return a + b;}
    static double Sum(double a, double b){return a + b;}

А что, если с точностью до нашей иерархии, а учитывая что можно делать `конкатенацию строк` - как описывать сумму двух 
строк? Абсолютно, аналогичным образом: 

    static String Sum(String a, String b){return a + b;}

Возвращаясь к вопросу: зачем нужен `Object`? Здесь достаточно просто, можно взять один отдельный метод, в котором 
указать в качестве аргументов `Object`'ы и дальше абсолютно спокойно проверить: `a instnaceof Double` (если `а` 
является `Double`, переменная `а` типа `Double`, или `а` принадлежит к типу `Double`) и `b` принадлежит к тому же 
типу - то берем переменную `a`, привести явно к типу `Double` - `(Double)`, сделать то же самое для переменной `b`. 
Затем получившееся преобразования сложить и результат обратно запаковать в тип `Object`.

    static Object Sum(Object a, Object b) {
        if (a instanceof Double && b instanceof Double) {
            return (Object) ((Double) a + (Double) b);
        } else if (a instanceof Integer && b instanceof  Integer) {
            return (Object) ((Integer) a + (Integer) b);
        } else return 0;
    }
0:9:21
Технически можно сделать так, что при возвращении типа `Object` у метода возвращаем `1,2` - это можно сделать. Но с 
точки зрения более правильного, грамотного описания: какие типы мы возвращаем; поэтому здесь в методе превращаем в тип
`Object`. Но в данном случае, это делать необязательно. 

> Сергей сказал, что сложить `String` можно методом `.concat()`.

Получается так, что метод один, но какое большое кол-во проверок. И если `if` будет состоять из 100-а веток, получается,
передавая 2 непонятных аргумента мы должны пробежать по всему этому каскаду `if`'ов и делать дополнительную проверку.
В связи с этим получается очень долгое выполнение этого самого метода, а как следствие это сказывается на 
производительности, а как следствие - это плохо.

Если код написан для одного человека - нормально, но если код написан для сервиса, которым пользуются тысячи, сотни 
тысяч человек. То в этом случае, потеря производительности будет очень-очень большой. Сейчас, когда мы начинаем 
проектировать должны думать о том, каким образом это должно работать. 

>Чем меньше преобразований из `Object` в `Object` - тем быстрее будет работать.

Даже если мы опишем каскад для всех типов, как нам кажется будут использованы - `Object` может принимать в себя всё 
что угодно и обязательно найдется пользователь который 100% укажет переменные типа, которые у нас не обрабатываются. 
И условная `Sum("маша", "каша") = 0`. 

>Используя тип `Object` нужно быть очень аккуратным. Т.е. прибегать к этому механизму упаковки-распаковки нужно 
> прибегать в крайнем-крайнем случае.

### Массивы.
Какие есть проблемы при использовании массивов?

Классический пример. Есть массив, состоящий из 2-х элементов. Что делать, если потребуется 3 эл-та, 4 эл-та, 5 эл-тов?
Если в `Python` есть список, то он "сам это сделает". И вот это "сам все сделает" - сильно сказывается на 
производительности.

Если задумаем написать такой функционал, то:
1. возьмем 1 массив;
2. дальше возьмем 2-й массив, увеличив его размер;
3. все элементы 1-го массива скопировать во 2-й;
4. и дальше работать со вторым массивом.

Пример. Есть массив из 2-х элементов. Потребовалось добавить 3-й элемент. 

    class Ex03_object {
        public static void main(String[] args) {
            int[] a = new int[] {1, 9};
            int[] b = new int[3];
            System.arraycopy(a, 0, b, 0, a.length);
        
            for (int i : a) { System.out.printf("%d ", i); }    // 1 9
        
            for (int j: b) { System.out.printf("%d ", j); }
            // 0 9 0 0 0 0 0 0 0 0
        } }

1. создан массив `a` с двумя элементами;
2. создан пустой массив `b` для 3-х элементов;
3. далее методом `.arraycopy()` указываем, что надо из массива `a` в `b` скопировать данные, начиная с `0`-го элемента
и всю длину массива (кол-во) `a.length` элементов массива `a`. 







быть положен в
#### sdfdsf
