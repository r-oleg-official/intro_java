## Почему вы не можете использовать API.

**API** (Application Programming Interface) - это контракт, который представляет
программа.
"Ко мне можно обращаться так и так, я обязуюсь делать это и это". 
[Habr](https://habr.com/ru/post/464261/)

API - возможности, которые предоставляют разработчики языка для удобного
взаимодействия с функционалом.

API, example:
1. строки
2. работа с файловой системой
3. логирование
4. импорт
5. xml

### Строки.

    String str = "";
    for (int i = 0; i < 1_000_000; i++){
    str += "+";
    }
    
    // ~ 41 000 ms.

Но есть другие способы работы со строками.

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 1_000_000; i++){
    sb.append("+");
    }

    // ~ 9 ms.

> Вывод. Если немного почитать док-цию, то можно ускорить свой код в несколько
> тысяч раз. 

> Ещё всегда надо задумываться о том, как будет работать код, если им будет 
> пользоваться не один человек, а множество.
 
Когда для себя нашел новое в документации, то хорошо чтобы куда-нибудь это 
записать.

    public class program {
        public static void main(String[] args) {
            var s = System.currentTimeMillis();
            String str = "";
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 1_000_000; i++) {
                str += "+";
                sb.append("+");
            }

            System.out.println(System.currentTimeMillis() - s);
            //System.out.println(str);
            //System.out.println(sb);
        }
    }

##### Доступные методы для строк.

* **concat():** - объединение строк  
* **value():** - преобразует Object в строковое представление (завязан на 
 <b>toString()</b>)
* **join():** - объединяет набор строк в одну с учетом разделителя 
* **charAt():** - получение символа по индексу
* **indexOf():** - первый индекс вхождения подстроки
* **lastIndexOf():** - последний индекс вхождения подстроки
* **startsWith()/endsWith():** - определяет, начинается/заканчивается ли 
 строка с подстроки 
* **replace():** - замена одной подстроки на другую.
* **trim():** - удаляет начальные и конечные пробелы
* **substring():** - возвращает подстроку, см. аргументы
* **toLowerCase()/toUpperCase():** - возвращает новую строку в нижнем/верхнем
 регистре
* **compareTo():** - сравнивает две строки
* **equals():** - сравнивает строки с учетом регистра
* **equalsIgnoreCase():** - сравнивает строки без учета регистра
* **regionMatches():** - сравнивает подстроки в строках

Весь функционал учить наизусть не нужно, но знать что он 
есть - желательно.
Например, это объединение строк, преобразование Object в строку, попытка 
преобразования числа в строку и т.д.

Далее можно посмотреть как класс. `StringBuilder` можно перевести в строку
и дальше использовать функционал на типе данных `string`.
Бывает иногда лучше использовать какой-нибудь ф.-нал напрямую из `StringBuilder`,
например, убрать какие-то лишние пробелы. 

##### Связь между массивами и строками.

    public static void name() {
        String[] name = {"О", "л","е","г"};
        String ok = "ОЛЕГ РА.";
        System.out.println(ok.toLowerCase());   // олег ра.
        System.out.println(String.join("", name));  // Олег
        System.out.println(String.join("", "О", "л","е","г"));  // Олег
        System.out.println(String.join(",", "О", "л","е","г")); // О,л,е,г

Когда кажется берешь стандартный ф.-нал для строки, в др. ЯП это было по-умолчанию массивом символов, пусть может быть
и не изменяемых - в Java такой прямой связи нет. Опять же надо прямо указать, используя ф.-нал, используя Java, 
превратить строку в набор символов и потом, может быть изменив, превратить опять в строку, чтобы работать с данными
как сос строкой.

##### Какой тип данных, в какой момент использовать?
`**String VS StringBuilder**`

Допустим, есть строки, то добавление в строки `String` - медленнее, чем в `StringBuilder`.

Когда выгоден:
* Много изменений - `String`;
* много преобразований - `StringBuilder`.

Если в рамках программы приходится много изменять строки, то выгоднее и логичнее использовать `StringBuilder`.
Если нужно просто искать какие-то данные в большой строке какой-то опред.-й кусочек, или какие-то вхождения подстрок 
- то в этом случае выгоднее использовать `String`.

> Если компоновка, т.е. сбор материала выгоднее использовать  `StringBuilder`.
> 
> Если разбор готового/полученного материала, то в этом случае выгоден `String`. 

#### Работа с файловой системой.
Главный вопрос: как много всякого разного в рамках файловой с-мы, напр., Linux/Mac/win - не имеет никакого значения?

Главный момент при работе файловой с-мы стоит отметить, что внутри есть 2 осн.-х "столпа":
1. каталоги;
2. файлы.

Фалов может быть великолепное множество, но по сути, они выглядят абсолютно одинаково - зашиты 1-цы и 0-ли, в 
определенной последовательности считывая, можно получить разные варианты данных: музыка, видео, текст, и т.п.

Для работы с файловой с-мой понадобиться один большой тип - `File`. И дальше, исходя из этого, посмотрев док-цию, 
вы можете обделать с ним всё что угодно: перемещать, копировать, замены, подмены и т.д.

> 0:09:03. ...посмотрев док-цию, вы можете обделать с ним всё что угодно...

    File <name> = new File(<full_path_to_file>);
    File f1 = new File("file.txt");
    File f2 = new File("/home/user/file.txt");

Что предпочтительнее?

Для конкретных типов файлов возможно изучить отдельные библ.-ки, возможно сам будешь создавать свои библ.-ки. 
Но идея от этого не поменяется.

Можно полностью загрузить файл в память и работать с ним, можно загрузить часть файла в память, проделать какие-то 
манипуляции, результат записать в файл и продолжить дальше порциями обрабатывать остальную часть файла.
Примерно по такому принципу, работает скачивание из Интернета.

> Но в любом случае, есть тонкости работы с файлами, напр., Java - кроссплатформенный ЯП, поэтому надо учитывать, что 
> ПО может быть запущено на разных платформах: Linux/Mac/win. Пути до файлов в этих ОС имеют разное представление.

Как обойти такие ограничения, связанные с платформой? Надо идти в док-цию по Java и искать как получить системный 
путь к папке, или получить путь к папке, в рамках которой запущен данный проект.

     import java.io.File;
     public class fileSystemDemo{
        public static void main(String[] args) {
            String pathProject = System.getProperty("user.dir");
            String pathFile = pathProject.concat("/file.txt");
            File f3 = new File(pathFile);
            System.out.println(f3.getAbsolutePath());
            // /Users/sk/vscode/java_projects/file.txt
            // C:\Users\Sk\Documents\xxx\brainexplotion\java\file.txt
        }
     }

Есть ещё что-то вроде `System.dir()`. Но в общем случае, constant-х значений сильно-сильно больше. Можно обязательно 
посмотреть док-ию. Этот курс будет построен чтобы посмотреть док-ию и дальше поэксперементировать на линукс- вин-машине.
Интересно и обязательно протестировать когда один пишет код на винд-машине, дальше этот исходный код дается человеку 
с другой ОС и запускается без каких-либо правок. Это идеальная ситуация, когда код может переноситься с одной платформы 
на другую.

Но есть одно большое НО. Когда взаимодействуешь с файловой с-мой - ошибок может быть великолепное кол-во:
1. указан неверный путь. Напр., был прописан абсолютный путь для винды, а код был запущен на Линукс - получится ошибка;
2. отсутствие какого-либо каталога;
3. отсутствие файла;
4. файл неверного типа был считан;
5. файл был очень большой, не хватило опер.-й памяти для полной загрузки;
6. файл пустой;
7. файл частично битый. Когда файл скачан из Интернета, соед-е Интернета разорвалось, часть файла осталась;
8. файл был открыт сторонней прогой, может вирус пытаться внедрить кусок своего кода;
9. антивирус в данный момент проверяет файл и не дает доступ считать файл;
и др.

Казалось, как с этим вообще работать? Как сделать чтобы код обходил эти острые углы. В Java и др. ЯП есть определенные 
блоки, позволяющие обрабатывать эти ошибки.

Самая основная идея обработки ошибок - исп.-е блока `try-catch`. Причем в блоке `try` писать код, который потенциально
может содержать ошибку. В блоке `catch` написать то, как реагировать на это исключение. Под исключением подразумевается
классическую ошибку, напр., нет файла - ПО "вылетает". Чтобы этого не случалось, делаем обертку `try/catch`, пишем
что "...файла не обнаружено, создайте его...", "файла не обнаружено, программа не может дальше продолжить работу. 
Кроме обязательных блоков `try`, `catch`  еще есть блок `finally`.

    try {
        Код, в котором может содержаться ошибка
    } catch (Exception e) {
        Обработка, если ошибка случилась
    }
    finally {
        Код, который выполнится в любом случае
    }

Задача. Напр., надо сделать код-ревью чего-то кода. 
Далее смотришь на код и могут возникнуть какие-то вопросы. В каком случае, напр., этот код не будет работать? Как с 
этим бороться?

    import java.io.File;
    public class tryDemo {
        public static void main(String[] args) {
            try {
                String pathProject = System.getProperty("user.dir");
                String pathFile = pathProject.concat("/file.txt");
                File f3 = new File(pathFile);
                System.out.println("try");
            } catch (Exception e) {
                System.out.println("catch");
            }
            finally {
                System.out.println("finally");
            }
        }
    }

0:15:23.

`pathProject` - прописываем путь к текущей папке с проектом. 

`pathFile` - указываем конкретный файл.

`File f3` - создаем файл, связать перем-ю `f3` с файлом по текущему пути. 

Если всё хорошо, то будет выведено сообщение `try`. Если файл будет отсутствовать, или путь будет "кривым", то получим 
сообщение `Exception` - `catch`. Блок `finally` обязательно, будет ли ошибка, или нет - выведет сообщение `finally`.

А всё ли хорошо ли с этим блоком `try/catch`? Если можно избавиться от такого блока - лучше от него избавиться.

    import java.io.File;
    public class tryDemo {
        public static void main(String[] args) {
            try {
                String pathProject = System.getProperty("user.dir");
                String pathFile = pathProject.concat("/file.txt");
                File file = new File(pathFile);
                if (file.createNewFile()) {
                    System.out.println("file.created");
                }
                else {
                    System.out.println("file.existed");
                }
            } catch (Exception e) {
                System.out.println("catch");
            }
            finally {
                System.out.println("finally");
            }
        }
    }

Если `file.createNewFile()` возвращает истину - это говорит, что файл был создан. Если возвращает `False` - это 
значит, что такой файл был найден и работать с ним быть может нужно по другому.

##### Функционал File с каталогами и файлами.

* **isHidden()**: - возвращает истину, если каталог или файл является скрытым
* **length()**: - возвращает размер файла в байтах
* **lastModified()**: - возвращает время последнего изменения файла или каталога
* **list()**: - возвращает массив файлов и подкаталогов, которые находятся в каталоге
* **listFiles()**: - возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
* **mkdir()**: - создает новый каталог
* **renameTo(File dest)**: - переименовывает файл или каталог.

##### Работа с файловой системой. Каталоги.

    import java.io.File;
    public class Ex0043 {
        public static void main(String[] args) {
            String pathProject = System.getProperty("user.dir");
            String pathDir = pathProject.concat("/files");
            File dir = new File(pathDir);
            System.out.println(dir.getAbsolutePath());
            if (dir.mkdir()) {
                System.out.println("+");
            } else {
                System.out.println("-");
            }
            for (String fname : dir.list()) {
                System.out.println(fname);
            }  }
    }

Как с файлами, так и с каталогами будет осуществляться работа в Линукс/винде, т.к. Java - кроссплатформенный ЯП.

##### Бинарные файлы.

В текстовых файлах информация представлена в том виде, в котором мы знаем.

Бинарные файлы содержат биты, которые нужно каким-то образом преобразовать, чтобы оттуда получить информацию в том 
виде, в котором сможет понять обычный пользователь. Для машины нет никакой разницы между бинарным и текстовым файлом.

Основной посыл по работе с бинарными файлами заключается в том, что теперь мы должны стараться смотреть не по 
принципу: вот есть какой-то `FileReader`, для того, чтобы работать, и мы начинаем полчаса думать как с этим `FileReader`
работать. Надо теперь стараться думать чуть-чуть шире.

В данном случае, если задача работать с бинарными файлами, мы должны выделить основной функционал, который позволяет
с этими файлами работать. А именно, быть может функция, позволяющая считывать данные, быть может это функция, 
позволяющая создавать данные, или создавать файл, в том числе. Быть может это функция поиска данных внутри этого 
бинарного файла. Или быть может вставка каких-то данных на определенную позицию и т.д. Сейчас опыта не так много, но
со временем его будет становиться больше и чем быстрее перейдешь на этап когда думаешь чуть-чуть более глобально 
нежели, "вот есть какой-то `Integer` и теперь я буду полчаса разбираться с этим типом данных `Integer`. Так не нужно.
Надо выделять основной функционал и дальше, исходя из этой задачи, напр., прочитать файл, начать гуглить, читать 
док.-цию о том как можно это сделать, примеры какие-то. Написали, оттестировали, проверили, подумали "какие ошибки 
могут возникать?", пошли дальше. Создали приложение - радуемся.

Демонстрация. 0:19:29.

Код можно будет скачать. 

Import. Если большое кол-во одинаковых файлов для импорта, то технически можно взять, напр., `java.io.` импортировать
всё `java.io.*`. 

> Нужно помнить, что когда ставишь `*`, (`java.io.*`), то в момент компиляции приложения Java залезет в эту библиотеку
и заберет абсолютно всё даже то, что не нужно.

> Обратить внимание! В примере каждый из этих методов содержит с одной стороны достаточно простой функционал, с другой 
стороны пока один раз не напишешь его - знать его не будешь. Нужно ли знать это наизусть - нет! Всегда в любой момент 
можно открыть Гугл, написать если потребуется, напр., `BufferedInputStream`, дальше переходишь в документацию Java и 
абсолютно спокойно читаете.

#### Логирование.

Есть определенное API, которое позволяет без каких-то ни было сложных телодвижений воспользоваться функционалом.

В чем суть логирования. Когда пишутся какие-то системы, рано или поздно эти системы начинают сбоить. Для того 
чтобы понять как отладить эту систему, надо посмотреть "что привело непосредственно к той, или иной ошибки?". 
Соответственно, нажатие какой-то кнопочки GUI, или выполнение какого-то отдельного метода, по-хорошему должно быть 
записано в журнал и дальше просмотрев все действия, которые привели к той, или ошибке - можно отладить систему и 
внести в неё необходимые правки.

0:24:51

    Использование
    Logger logger = Logger.getLogger();
    
    Уровни важности
    INFO, DEBUG, ERROR, WARNING и др.
    
    Вывод
    ConsoleHandler info = new ConsoleHandler();
    log.addHandler(info);
    
    Формат вывода: структурированный, абы как*
    XMLFormatter, SimpleFormatter
   
Для внедрения в систему логирования:
1. создать переменную типа `Logger` и в `getLogger()` указать тип, или наименование класса, для которого мы будем это
логирование добавлять;
2. есть несколько уровней важности ошибки. Информационные сообщения `INFO` можно добавить, напр., каждые 15 мин, т.е.
система в 10.00 работает корректно, в 10.15 система работает корректно и т.д. Дальше может пойти что-то не так и 
можно пометить данный лог, или данное сообщение конкретным флагом: `DEBUG`, или `WARNING`, или что-то ещё;
3. когда описываешь это логирование, надо указать куда показывать эти логи, или сохранять, или может быть отправлять
в БД, или куда-то ещё. Нужно указать `Handler` и в каком формате. Класс-й вариант - в виде сообщений, или `*.xml`.

Как использовать логирование в контексте Java?

    import java.util.logging.ConsoleHandler;
    import java.util.logging.Logger;
    import java.util.logging.SimpleFormatter;
    import java.util.logging.XMLFormatter;

    public class Ex005_Logger {
        public static void main(String[] args) {
            Logger logger = Logger.getLogger(Ex005_Logger.class.getName());
            ConsoleHandler ch = new ConsoleHandler();

            logger.addHandler(ch);

            //SimpleFormatter sFormat = new SimpleFormatter();
            XMLFormatter xml = new XMLFormatter();
            //ch.setFormatter(sFormat);
            ch.setFormatter(xml);
            
            //logger.setLevel((Level.INFO));
            logger.log(Level.WARNING, "Тестовое логгирование 1");
            logger.info("Тестовое логгирование 2");
        }
    }

Создали перем-ю типа `Logger`, далее в `getLogger()` указали имя класса, для которого добавили это логирование.
Далее создали `Handler` - `ch`, `ConsoleHandler`, т.е. все ошибки/сообщения будут выпадать в терминал. Далее этот 
`ch` указать в качестве аргумента `logger.` чтобы было понятно куда отправлять сообщения. Далее создать формат этих
сообщений, либо `SimpleFormatter`, либо `XMLFormatter`. 0:27:10

После этого `logger.log()` позволяет указать уровень сообщений и то сообщение, которое нужно показать. Если неохота
указывать флажок `Level.Warning`, а в большинстве случаев так как не делается, то можно указать `logger.info()` и то 
сообщение, которое требуется.

Теперь известно как выводить сообщения в консоль. А как выводить сообщение в файл?
Если известен какой-нибудь `ConsoleHandler`, то возможно есть какой-нибудь `FileHandler`. Обычно наименование 
производится так, что зная одно, можно было бы додумать и другое. Напр., если нужно работать с БД, то может быть
есть какой-нибудь `...Handler`.

    FileHandler fh = new FileHandler("log.xml");
    logger.addHandler(fh);
    XMLFormatter xml = new XMLFormatter();
    fh.setFormatter(xml);
    logger.log(Level.WARNING, "Тестовое логгирование 1");
    logger.info("Тестовое логгирование 2");

В качестве самостоятельной работы: взять и свести в один проект текущие два: работа с бинарными файлами и логирование.
Подключит логирование к каждому из методов.

"Здесь вам не тут!"
