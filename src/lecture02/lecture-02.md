## Почему вы не можете использовать API.

**API** (Application Programming Interface) - это контракт, который представляет
программа.
"Ко мне можно обращаться так и так, я обязуюсь делать это и это". 
[Habr](https://habr.com/ru/post/464261/)

API - возможности, которые предоставляют разработчики языка для удобного
взаимодействия с функционалом.

API, example:
1. строки
2. работа с файловой системой
3. логирование
4. импорт
5. xml

### Строки.

    String str = "";
    for (int i = 0; i < 1_000_000; i++){
    str += "+";
    }
    
    // ~ 41 000 ms.

Но есть другие способы работы со строками.

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 1_000_000; i++){
    sb.append("+");
    }

    // ~ 9 ms.

> Вывод. Если немного почитать док-цию, то можно ускорить свой код в несколько
> тысяч раз. 

> Ещё всегда надо задумываться о том, как будет работать код, если им будет 
> пользоваться не один человек, а множество.
 
Когда для себя нашел новое в документации, то хорошо чтобы куда-нибудь это 
записать.

    public class program {
        public static void main(String[] args) {
            var s = System.currentTimeMillis();
            String str = "";
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 1_000_000; i++) {
                str += "+";
                sb.append("+");
            }

            System.out.println(System.currentTimeMillis() - s);
            //System.out.println(str);
            //System.out.println(sb);
        }
    }

##### Доступные методы для строк.

* **concat():** - объединение строк  
* **value():** - преобразует Object в строковое представление (завязан на 
 <b>toString()</b>)
* **join():** - объединяет набор строк в одну с учетом разделителя 
* **charAt():** - получение символа по индексу
* **indexOf():** - первый индекс вхождения подстроки
* **lastIndexOf():** - последний индекс вхождения подстроки
* **startsWith()/endsWith():** - определяет, начинается/заканчивается ли 
 строка с подстроки 
* **replace():** - замена одной подстроки на другую.
* **trim():** - удаляет начальные и конечные пробелы
* **substring():** - возвращает подстроку, см. аргументы
* **toLowerCase()/toUpperCase():** - возвращает новую строку в нижнем/верхнем
 регистре
* **compareTo():** - сравнивает две строки
* **equals():** - сравнивает строки с учетом регистра
* **equalsIgnoreCase():** - сравнивает строки без учета регистра
* **regionMatches():** - сравнивает подстроки в строках

Весь функционал учить наизусть не нужно, но знать что он 
есть - желательно.
Например, это объединение строк, преобразование Object в строку, попытка 
преобразования числа в строку и т.д.

Далее можно посмотреть как класс. `StringBuilder` можно перевести в строку
и дальше использовать функционал на типе данных `string`.
Бывает иногда лучше использовать какой-нибудь ф.-нал напрямую из `StringBuilder`,
например, убрать какие-то лишние пробелы. 

##### Связь между массивами и строками.

    public static void name() {
        String[] name = {"О", "л","е","г"};
        String ok = "ОЛЕГ РА.";
        System.out.println(ok.toLowerCase());   // олег ра.
        System.out.println(String.join("", name));  // Олег
        System.out.println(String.join("", "О", "л","е","г"));  // Олег
        System.out.println(String.join(",", "О", "л","е","г")); // О,л,е,г

Когда кажется берешь стандартный ф.-нал для строки, в др. ЯП это было по-умолчанию массивом символов, пусть может быть
и не изменяемых - в Java такой прямой связи нет. Опять же надо прямо указать, используя ф.-нал, используя Java, 
превратить строку в набор символов и потом, может быть изменив, превратить опять в строку, чтобы работать с данными
как сос строкой.

##### Какой тип данных, в какой момент использовать?
`**String VS StringBuilder**`

Допустим, есть строки, то добавление в строки `String` - медленнее, чем в `StringBuilder`.

Когда выгоден:
* Много изменений - `String`;
* много преобразований - `StringBuilder`.

Если в рамках программы приходится много изменять строки, то выгоднее и логичнее использовать `StringBuilder`.
Если нужно просто искать какие-то данные в большой строке какой-то опред.-й кусочек, или какие-то вхождения подстрок - то
в этом случае выгоднее использовать `String`.

> Если компоновка, т.е. сбор материала выгоднее использовать  `StringBuilder`.
> 
> Если разбор готового/полученного материала, то в этом случае выгоден `String`. 

#### Работа с файловой системой.
Главный вопрос: как много всякого разного в рамках файловой с-мы, напр., Linux/Mac/win - не имеет никакого значения?

Главный момент при работе файловой с-мы стоит отметить, что внутри есть 2 осн.-х "столпа":
1. каталоги;
2. файлы.

Фалов может быть великолепное множество, но по сути, они выглядят абсолютно одинаково - зашиты 1-цы и 0-ли, в 
определенной последовательности считывая, можно получить разные варианты данных: музыка, видео, текст, и т.п.

Для работы с файловой с-мой понадобиться один большой тип - `File`. И дальше, исходя из этого, посмотрев док-цию, 
вы можете обделать с ним всё что угодно: перемещать, копировать, замены, подмены и т.д.

> 0:09:03. ...посмотрев док-цию, вы можете обделать с ним всё что угодно...

    File <name> = new File(<full_path_to_file>);
    File f1 = new File("file.txt");
    File f2 = new File("/home/user/file.txt");

Что предпочтительнее?

Для конкретных типов файлов возможно изучить отдельные библ.-ки, возможно сам будешь создавать свои библ.-ки. 
Но идея от этого не поменяется.

Можно полностью загрузить файл в память и работать с ним, можно загрузить часть файла в память, проделать какие-то 
манипуляции, результат записать в файл и продолжить дальше порциями обрабатывать остальную часть файла.
Примерно по такому принципу, работает скачивание из Интернета.

> Но в любом случае, есть тонкости работы с файлами, напр., Java - кроссплатформенный ЯП, поэтому надо учитывать, что 
> ПО может быть запущено на разных платформах: Linux/Mac/win. Пути до файлов в этих ОС имеют разное представление.

Как обойти такие ограничения, связанные с платформой? Надо идти в док-цию по Java и искать как получить системный 
путь к папке, или получить путь к папке, в рамках которой запущен данный проект.

     import java.io.File;
     public class fileSystemDemo{
        public static void main(String[] args) {
            String pathProject = System.getProperty("user.dir");
            String pathFile = pathProject.concat("/file.txt");
            File f3 = new File(pathFile);
            System.out.println(f3.getAbsolutePath());
            // /Users/sk/vscode/java_projects/file.txt
            // C:\Users\Sk\Documents\xxx\brainexplotion\java\file.txt
        }
     }

Есть ещё что-то вроде `System.dir()`. Но в общем случае, constant-х значений сильно-сильно больше. Можно обязательно 
посмотреть док-ию. Этот курс будет построен чтобы посмотреть док-ию и дальше поэксперементировать на линукс- вин-машине.
Интересно и обязательно потестировать когда один пишет код на винд-машине, дальше этот исходный код дается человеку 
с другой ОС и запускается без каких-либо правок. Это идеальная ситуация, когда код может переносится с одной платформы 
на другую.

Но есть одно большое НО. Когда взаимодействуешь с файловой с-мой - ошибок может быть великолепное кол-во:
1. указан неверный путь. Напр., был прописан абсолютный путь для винды, а код был запущен на Линукс - получится ошибка;
2. отсутствие какого-либо каталога;
3. отсутствие файла;
4. файл неверного типа был считан;
5. файл был очень большой, нехватило опер.-й памяти для полной загрузки;
6. файл пустой;
7. файл частично битый. Когда файл скачан из Интернета, соед-е Интернета разорвалось, часть файла осталась;
8. файл был открыт сторонней прогой, может вирус пытается внедрить кусок своего кода;
9. антивирус в данный момент проверяет файл и не дает доступ считать файл;
и др.

Казалось, как с этим вообще работать? Как сделать чтобы код обходил эти острые углы. В Java и др. ЯП есть определенные 
блоки, позволяющие обрабатывать эти ошибки.

Самая основная идея обработки ошибок - исп.-е блока `try-catch`. Причем в блоке `try` писать код, который потенциально
может содержать ошибку. В блоке `catch` написать то, как реагировать на это исключение. Под исключением подразумевается
классическую ошибку, напр., нет файла - ПО "вылетает". Чтобы этого не случалось, делаем обертку `try/catch`, пишем
что "файла не обнаружено, создайте его", "файла не обнаружено, программа не может дальше продолжить работу. 
Кроме обязательных блоков `try`, `catch`  еще есть блок `finally`.


    try {
        Код, в котором может содержаться ошибка
    } catch (Exception e) {
        Обработка, если ошибка случилась
    }
    finally {
        Код, который выполнится в любом случае
    }

Задача. Напр., надо сделать код-ревью чего-то кода. 
Далее смотришь на код и могут возникнуть какие-то вопросы. В каком случае, напр., этот код не будет работать? Как с 
этим бороться?

    import java.io.File;
    public class tryDemo {
        public static void main(String[] args) {
            try {
                String pathProject = System.getProperty("user.dir");
                String pathFile = pathProject.concat("/file.txt");
                File f3 = new File(pathFile);
                System.out.println("try");
            } catch (Exception e) {
                System.out.println("catch");
            }
            finally {
                System.out.println("finally");
            }
        }
    }

0:15:23.






